<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>물리학과 딥러닝: 개념 탐험</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Brilliant Blues -->
    <!-- Application Structure Plan: A single-page application with a top navigation bar to switch between thematic sections: '소개', '초기 모델', '물리학 원리', '현대적 과제'. This non-linear, modular structure allows users to explore complex topics at their own pace. Each section uses a combination of explanatory text and interactive visualizations (diagrams, charts) to make abstract concepts more intuitive and digestible than a simple text document. -->
    <!-- Visualization & Content Choices: Source Report Info: Hopfield Network -> Goal: Inform/Organize -> Viz: Interactive HTML Grid -> Interaction: Add noise/recover -> Justification: Demonstrates associative memory in action. Source Report Info: Sparsity Principle -> Goal: Compare/Inform -> Viz: Chart.js Bar Chart -> Interaction: Hover for details -> Justification: Visually quantifies the dramatic parameter reduction. Source Report Info: Criticality -> Goal: Relationships -> Viz: Chart.js Line Chart -> Interaction: Hover for details -> Justification: Shows the performance peak at the critical point. Source Report Info: CNN vs. Capsule Net -> Goal: Compare -> Viz: HTML/CSS Diagram -> Interaction: Static comparison -> Justification: Clearly contrasts the two architectures' approaches to spatial data. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #F0F9FF; color: #0369A1; }
        .nav-btn { transition: all 0.3s ease; border: 2px solid transparent; }
        .nav-btn.active { background-color: #0077B6; color: #FFFFFF; border-color: #00B4D8; }
        .nav-btn:hover:not(.active) { background-color: #CAF0F8; color: #0077B6; }
        .content-section { display: none; }
        .content-section.active { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .chart-container { position: relative; width: 100%; max-width: 600px; margin-left: auto; margin-right: auto; height: 350px; max-height: 400px; }
        @media (min-width: 768px) { .chart-container { height: 400px; } }
        .concept-card { background-color: #FFFFFF; border-radius: 0.75rem; padding: 1.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.05); border-left: 5px solid #00B4D8; }
        .hopfield-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; width: 120px; height: 120px; margin: 0 auto; }
        .hopfield-cell { width: 100%; height: 100%; border: 1px solid #90E0EF; cursor: pointer; transition: background-color 0.2s; }
        .hopfield-cell.on { background-color: #0077B6; }
        .flow-diagram-step { text-align: center; padding: 0.5rem; border: 2px solid #90E0EF; border-radius: 0.5rem; background-color: #CAF0F8; color: #0077B6; font-weight: 500;}
        .flow-arrow { text-align: center; font-size: 2rem; color: #00B4D8; line-height: 1; }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl md:text-5xl font-bold text-sky-800">물리학과 딥러닝: 개념 탐험</h1>
            <p class="text-lg text-sky-600 mt-2">물리학의 눈으로 바라본 인공지능의 원리</p>
        </header>

        <nav class="flex flex-wrap justify-center gap-2 md:gap-4 mb-10 p-2 bg-white/70 backdrop-blur-sm rounded-full shadow-md sticky top-4 z-10">
            <button class="nav-btn px-4 py-2 rounded-full font-semibold active" data-target="intro">소개</button>
            <button class="nav-btn px-4 py-2 rounded-full font-semibold" data-target="early-models">초기 모델</button>
            <button class="nav-btn px-4 py-2 rounded-full font-semibold" data-target="physics-principles">물리학 원리</button>
            <button class="nav-btn px-4 py-2 rounded-full font-semibold" data-target="modern-challenges">현대적 과제</button>
        </nav>

        <main>
            <section id="intro" class="content-section active">
                <div class="concept-card max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-4 text-sky-700">딥러닝, 물리학에서 길을 찾다</h2>
                    <p class="text-gray-700 leading-relaxed">
                        인공지능과 딥러닝은 흔히 컴퓨터 과학의 산물로 여겨지지만, 그 뿌리는 물리학의 깊은 통찰력과 맞닿아 있습니다. 특히 **생물리학, 통계 물리학, 계산 물리학**의 아이디어들은 인공 신경망의 개념을 탄생시키고 발전시키는 데 결정적인 역할을 했습니다. 우리 뇌의 뉴런이 작동하는 방식을 모방하려는 시도에서부터, 수많은 입자의 집단적 행동을 설명하는 통계 역학의 원리까지, 물리학은 딥러닝이라는 새로운 지평을 여는 나침반이 되었습니다.
                    </p>
                    <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6 text-center">
                        <div class="p-4 bg-sky-50 rounded-lg border border-sky-200">
                            <h3 class="font-bold text-lg text-sky-800">존 홉필드 (John Hopfield)</h3>
                            <p class="text-sm text-sky-500">물리학자</p>
                            <p class="mt-2 text-gray-600 text-sm">자성체의 원리를 이용해 '연관 메모리'를 구현한 홉필드 네트워크를 개발했습니다.</p>
                        </div>
                        <div class="p-4 bg-sky-50 rounded-lg border border-sky-200">
                            <h3 class="font-bold text-lg text-sky-800">제프리 힌턴 (Geoffrey Hinton)</h3>
                            <p class="text-sm text-sky-500">인지심리학자, 컴퓨터 과학자</p>
                            <p class="mt-2 text-gray-600 text-sm">홉필드 네트워크를 발전시켜 '볼츠만 머신'을 제안하고, 딥러닝의 시대를 열었습니다.</p>
                        </div>
                    </div>
                </div>
            </section>

            <section id="early-models" class="content-section">
                 <div class="concept-card max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-4 text-sky-700">초기 신경망 모델: 가능성의 씨앗</h2>
                    <p class="text-gray-700 leading-relaxed mb-6">
                        딥러닝의 여정은 뇌의 작동 방식에서 영감을 받은 초기 모델들로부터 시작되었습니다. 이 모델들은 물리학적 원리를 바탕으로 '기억'과 '학습'의 가능성을 탐구했습니다.
                    </p>
                    <div class="bg-white p-6 rounded-lg shadow-inner border border-gray-200">
                        <h3 class="text-2xl font-bold text-blue-600 mb-3 text-center">홉필드 네트워크: 에너지로 기억하다</h3>
                        <div class="grid md:grid-cols-2 gap-8 items-center">
                            <div>
                                <p class="text-gray-600 mb-4">홉필드 네트워크는 자성체가 안정적인 상태(최저 에너지)를 찾아가듯, 불완전한 입력이 주어져도 미리 학습된 가장 유사한 패턴으로 수렴합니다. 이를 **연관 메모리**라고 합니다. 네트워크는 각 패턴을 에너지 지형의 '골짜기'로 기억하며, 입력이 주어지면 가장 가까운 골짜기로 굴러갑니다.</p>
                                <p class="text-gray-600 font-medium">아래 'C' 패턴에 노이즈를 추가하고 '복구' 버튼을 눌러보세요.</p>
                                <div class="flex gap-4 mt-4 justify-center md:justify-start">
                                    <button id="addNoiseBtn" class="px-4 py-2 bg-blue-500 text-white rounded-full hover:bg-blue-600 transition shadow-md">노이즈 추가</button>
                                    <button id="recoverBtn" class="px-4 py-2 bg-green-500 text-white rounded-full hover:bg-green-600 transition shadow-md">패턴 복구</button>
                                </div>
                            </div>
                            <div class="flex flex-col items-center">
                                <div id="hopfieldGrid" class="hopfield-grid mb-4"></div>
                            </div>
                        </div>
                         <h3 class="text-2xl font-bold text-purple-600 mt-10 mb-3 text-center">볼츠만 머신: 숨겨진 패턴을 찾아서</h3>
                        <p class="text-gray-600 mb-4 text-center">홉필드 네트워크는 저장된 패턴만 복구할 수 있었지만, 제프리 힌턴의 **볼츠만 머신**은 **숨겨진 레이어(Hidden Layer)**를 도입하여 한계를 극복했습니다. 이 숨겨진 노드들은 데이터의 보이지 않는 추상적인 특징을 학습하여, 단순히 패턴을 기억하는 것을 넘어 데이터의 통계적 분포를 이해하고 **새로운 패턴을 생성**할 수 있는 가능성을 열었습니다. 이는 딥러닝이 '생성 모델'로 나아가는 중요한 첫걸음이었습니다.</p>
                    </div>
                </div>
            </section>

            <section id="physics-principles" class="content-section">
                <div class="concept-card max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-4 text-sky-700">딥러닝을 관통하는 물리학 원리</h2>
                    <p class="text-gray-700 leading-relaxed mb-6">
                        딥러닝 모델이 효과적으로 작동하는 이유는 물리학의 근본 원리들과 깊은 관련이 있습니다. 희소성, 재규격화군 흐름, 임계성은 딥러닝의 블랙박스를 이해하는 중요한 열쇠입니다.
                    </p>
                    <div class="space-y-12">
                        <div>
                            <h3 class="text-2xl font-bold text-green-600 mb-3">희소성: 복잡함 속의 단순함</h3>
                            <p class="text-gray-600 mb-4">물리학 이론과 마찬가지로, 성공적인 딥러닝 모델은 본질적으로 **희소(sparse)**합니다. 즉, 수많은 매개변수 중 소수만이 특정 패턴을 설명하는 데 결정적인 역할을 합니다. 이는 '자유 점심 없음 정리'의 한계를 극복하고, 구조화된 실제 데이터에서 의미 있는 패턴을 효율적으로 학습할 수 있게 합니다. 아래 차트는 이론이 단순화(희소해질수록) 매개변수 수가 어떻게 급격히 줄어드는지 보여줍니다.</p>
                            <div class="chart-container bg-white p-4 rounded-lg shadow-md">
                                <canvas id="sparsityChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-red-600 mb-3">재규격화군 흐름: 스케일을 넘나드는 학습</h3>
                            <p class="text-gray-600 mb-4">물리학의 **재규격화군(RG) 흐름**은 다른 스케일에서 시스템을 볼 때 본질적인 특징이 어떻게 드러나는지 설명합니다. 딥러닝에서 각 레이어는 다른 '스케일'에 해당합니다. 네트워크가 깊어지면서 미시적인 세부 정보(픽셀)는 걸러지고, 거시적인 개념(객체)이 드러나는 **표현 학습**이 일어납니다. 이는 데이터의 본질을 압축하는 과정입니다.</p>
                            <div class="flex flex-col items-center space-y-2 mt-4">
                                <div class="flow-diagram-step w-1/2">픽셀 (미시적)</div>
                                <div class="flow-arrow">↓</div>
                                <div class="flow-diagram-step w-2/3">선, 모서리</div>
                                <div class="flow-arrow">↓</div>
                                <div class="flow-diagram-step w-5/6">눈, 코, 입</div>
                                <div class="flow-arrow">↓</div>
                                <div class="flow-diagram-step w-full bg-red-200 text-red-800 border-red-400">얼굴 (거시적)</div>
                            </div>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-orange-500 mb-3">임계성: 최적 학습의 경계</h3>
                            <p class="text-gray-600 mb-4">시스템이 질적으로 변하는 경계인 **임계점**에서 딥러닝 모델은 가장 효율적으로 학습합니다. 이 상태에서 정보(신호)는 소실되거나 폭발하지 않고 안정적으로 네트워크를 통해 전파됩니다. 하이퍼파라미터 튜닝은 네트워크를 이 '임계점'에 가깝게 조율하여, 표현 학습 능력을 극대화하는 과정으로 볼 수 있습니다.</p>
                            <div class="chart-container bg-white p-4 rounded-lg shadow-md">
                                <canvas id="criticalityChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <section id="modern-challenges" class="content-section">
                <div class="concept-card max-w-4xl mx-auto">
                    <h2 class="text-3xl font-bold mb-4 text-sky-700">현대적 과제: 인간처럼 보기 위하여</h2>
                    <p class="text-gray-700 leading-relaxed mb-6">
                        딥러닝은 눈부신 발전을 이루었지만, 여전히 인간의 인식 능력과는 차이가 있습니다. 특히 객체의 부분과 전체의 관계를 이해하는 것은 중요한 과제입니다.
                    </p>
                    <div class="space-y-8">
                        <div>
                            <h3 class="text-2xl font-bold text-indigo-600 mb-3">CNN의 한계와 캡슐 네트워크</h3>
                            <p class="text-gray-600 mb-4">**합성곱 신경망(CNN)**은 필터의 가중치 공유를 통해 객체가 이미지 어디에 있든 인식하는 **이동 불변성**을 확보했습니다. 하지만 눈, 코, 입의 위치가 뒤섞여도 '얼굴'로 잘못 인식하는 등, 부분들의 **공간적 관계**를 파악하는 데는 한계가 있습니다.</p>
                            <p class="text-gray-600 mb-4">이를 해결하기 위해 제프리 힌턴은 **캡슐 네트워크**를 제안했습니다. 캡슐은 단순한 활성화 값이 아닌, 객체의 위치, 크기, 각도 등 '자세' 정보를 담은 벡터를 출력합니다. **동적 라우팅**을 통해 하위 캡슐들(눈, 코)이 상위 캡슐(얼굴)의 구조와 얼마나 일치하는지 반복적으로 확인하여, 부분과 전체의 관계를 훨씬 정교하게 학습합니다.</p>
                        </div>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-6 p-4 bg-gray-50 rounded-lg">
                            <div class="text-center p-4 border-r border-gray-200">
                                <h4 class="font-bold text-lg mb-2 text-gray-800">CNN의 방식</h4>
                                <p class="text-sm text-gray-600">"눈, 코, 입이 존재하므로 얼굴이다."<br>(위치 관계는 덜 중요)</p>
                                <div class="mt-4 p-4 bg-red-100 rounded-md">
                                    <p class="font-mono text-sm text-red-800">얼굴 특징이 뒤섞여도<br>'얼굴'로 인식할 수 있음</p>
                                </div>
                            </div>
                            <div class="text-center p-4">
                                <h4 class="font-bold text-lg mb-2 text-gray-800">캡슐 네트워크의 방식</h4>
                                <p class="text-sm text-gray-600">"눈, 코, 입이 올바른 위치 관계에 있으므로 얼굴이다."</p>
                                 <div class="mt-4 p-4 bg-green-100 rounded-md">
                                    <p class="font-mono text-sm text-green-800">부분들의 구조적 일치를 확인하여<br>더 정확하게 판단</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const navButtons = document.querySelectorAll('.nav-btn');
            const contentSections = document.querySelectorAll('.content-section');
            const hopfieldGrid = document.getElementById('hopfieldGrid');
            const addNoiseBtn = document.getElementById('addNoiseBtn');
            const recoverBtn = document.getElementById('recoverBtn');

            const patternC = [
                0, 1, 1, 1, 0,
                1, 0, 0, 0, 0,
                1, 0, 0, 0, 0,
                1, 0, 0, 0, 0,
                0, 1, 1, 1, 0
            ];
            let currentGridState = [...patternC];

            function renderGrid(state) {
                if (!hopfieldGrid) return;
                hopfieldGrid.innerHTML = '';
                state.forEach((cellState, index) => {
                    const cell = document.createElement('div');
                    cell.classList.add('hopfield-cell');
                    if (cellState === 1) cell.classList.add('on');
                    cell.dataset.index = index;
                    hopfieldGrid.appendChild(cell);
                });
            }
            
            if(addNoiseBtn) {
                addNoiseBtn.addEventListener('click', () => {
                    currentGridState = currentGridState.map(cell => Math.random() < 0.2 ? 1 - cell : cell);
                    renderGrid(currentGridState);
                });
            }

            if(recoverBtn) {
                recoverBtn.addEventListener('click', () => {
                    currentGridState = [...patternC];
                    renderGrid(currentGridState);
                });
            }

            let chartInstances = {};
            function switchTab(targetId) {
                navButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.target === targetId);
                });
                contentSections.forEach(section => {
                    section.classList.toggle('active', section.id === targetId);
                });

                if (targetId === 'physics-principles') {
                    createSparsityChart();
                    createCriticalityChart();
                }
            }

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    switchTab(button.dataset.target);
                });
            });

            const defaultTooltipCallback = {
                title: function(tooltipItems) {
                    const item = tooltipItems[0];
                    let label = item.chart.data.labels[item.dataIndex];
                    return Array.isArray(label) ? label.join(' ') : label;
                }
            };

            function createSparsityChart() {
                const chartId = 'sparsityChart';
                if (chartInstances[chartId]) return;
                const ctx = document.getElementById(chartId);
                if (!ctx) return;
                chartInstances[chartId] = new Chart(ctx.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: ['일반 이론', 'k-지역성', ['공간적', '지역성'], ['이동', '불변성']],
                        datasets: [{
                            label: '매개변수 수',
                            data: [100, 60, 20, 1],
                            backgroundColor: ['#CAF0F8', '#90E0EF', '#00B4D8', '#0077B6'],
                            borderColor: '#0369A1',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: '이론의 희소성과 매개변수 수', color: '#0369A1', font: { size: 16 } },
                            legend: { display: false },
                            tooltip: { callbacks: { ...defaultTooltipCallback, 
                                label: function(context) {
                                    const labels = ['~2^N', '~N^k', '~N', '~O(1)'];
                                    return `매개변수: ${labels[context.dataIndex]}`;
                                }
                            }}
                        },
                        scales: {
                            y: { type: 'logarithmic', title: { display: true, text: '매개변수 수 (로그 스케일)' } }
                        }
                    }
                });
            }

            function createCriticalityChart() {
                const chartId = 'criticalityChart';
                if (chartInstances[chartId]) return;
                const ctx = document.getElementById(chartId);
                if (!ctx) return;
                chartInstances[chartId] = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: ['0.0', '0.2', '0.4', '0.6', '0.8', '1.0', '1.2', '1.4', '1.6'],
                        datasets: [{
                            label: '모델 성능',
                            data: [10, 30, 80, 95, 100, 90, 60, 20, 5],
                            fill: false,
                            borderColor: '#F97316',
                            backgroundColor: '#F97316',
                            tension: 0.4,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: '임계점과 모델 성능', color: '#0369A1', font: { size: 16 } },
                            legend: { display: false },
                            tooltip: { callbacks: defaultTooltipCallback },
                            annotation: {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: '0.8', xMax: '0.8',
                                        borderColor: 'rgba(255, 99, 132, 0.8)',
                                        borderWidth: 2,
                                        borderDash: [6, 6],
                                        label: { content: '임계점', enabled: true, position: 'start', yAdjust: -15, backgroundColor: 'rgba(255, 99, 132, 0.8)' }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { title: { display: true, text: '하이퍼파라미터 (예: L/N 비율)' } },
                            y: { title: { display: true, text: '성능' }, suggestedMin: 0, suggestedMax: 110 }
                        }
                    }
                });
            }
            
            renderGrid(currentGridState);
            switchTab('intro');
        });
    </script>
</body>
</html>
